#!/bin/env python3
# vim: set ts=4 sw=4 :
# vim: set noexpandtab :

import sys
import io

import locale
import inspect

import docutils.utils
import docutils.parsers.rst

import argparse
import json

import locale

import lxml.etree 

class DocumentSettings:
	def __init__( self ):
		self.tab_width = 8
		self.report_level = 10
		self.halt_level = 20
		self.warning_stream = sys.stderr
		self.debug = False
		self.error_encoding = None
		self.error_encoding_error_handler = None
		self.language_code = "EN"
		self.pep_references = None
		self.rfc_references = None
		self.id_prefix = ""


class Parameter( object ):

class Parameters( object ):


class Method( object ):



class DocumentProcessor( object ):

	class State( object ):
		def __init__( self ):
			return

	@staticmethod
	def check( condition, message, *, asrt=False ):
		if not condition:
			if asrt and not __debug__: raise AssertionError( message )
			raise RuntimeError( message )
		return

	@staticmethod
	def xpath( element, path, *, count=None, must_exist, asrt=False, msg="" ):
		verbose_write( 3, "{}:element = {}".format( msg, lxml.etree.tostring( element ).decode( "utf-8" ) ), stack_depth=2 )
		verbose_write( 1, "{}:xpath = {}".format( msg, path ), stack_depth=2 )
		result = element.xpath( path )
		verbose_write( 2, "{}:result = {}, len( result ) = {}".format( msg, result, len( result ) ), stack_depth=2 )
		if must_exist:
			DocumentProcessor.check( ( result is not None ) and ( len( result ) > 0 ), "{}:xpath query [{}] did not yield results.".format( msg, path ) )
		if count is not None:
			DocumentProcessor.check( count( len( result ) ), "{}:xpath query [{}] got {} results, expected something else".format( msg, path, len( result ) ) )
		return result;

	def __init__( self ):
		self.global_parameters = []
		self.common_response_codes = []
		return

	def process( self, root ):
		api_sections = self.xpath( root.getroottree(), "//section[ ( starts-with( section/definition_list/definition_list_item/term, 'URL' ) ) or ( section/definition_list/definition_list_item/term = 'URL:' ) ]", must_exist = False, msg="looking for api sections inside document" )
		if api_sections is not None:
			for api_section in api_sections:
				self.process_api_section( api_section )

		global_parameters = self.xpath( root.getroottree(), "//section[ title = 'Global Parameters' ]/definition_list/definition_list_item/definition/bullet_list/list_item/paragraph", must_exist = False, msg="looking for global_parameters inside document" )
		verbose_write( 0, "global_parameters = {}".format( [ lxml.etree.tostring( global_parameter ).decode( "utf-8" ) for global_parameter in global_parameters ] ) )
		self.global_parameters += global_parameters

		common_response_codes = self.xpath( root.getroottree(), "//section[ title = 'Common Response Codes' ]/definition_list/definition_list_item/definition/bullet_list/list_item/paragraph", must_exist = False, msg="looking for common_response_codes inside document" )
		verbose_write( 0, "common_response_codes = {}".format( [ lxml.etree.tostring( common_response_code ).decode( "utf-8" ) for common_response_code in common_response_codes ] ) )
		self.common_response_codes += common_response_codes

		return
	
	def process_api_section( self, api_section ):
		verbose_write( 3, "api_section = {}".format( lxml.etree.tostring( api_section ).decode( "utf-8" ) ) )

		method_sections = self.xpath( root.getroottree(), "./section/section[ ( starts-with( definition_list/definition_list_item/term, 'URL' ) ) or ( starts-with( definition_list/definition_list_item/term, 'API Address' ) ) ]", count=( lambda x: x >= 1 ), must_exist = True, asrt = True, msg="looking for method sections inside api section" )
		for method_section in method_sections:
			self.process_method_section( method_section )
		return

	def process_method_section( self, method_section ):
		verbose_write( 2, "method_section = {}".format( lxml.etree.tostring( method_section ).decode( "utf-8" ) ) )
		definition_list = self.xpath( method_section, "./definition_list", count=( lambda x: x >= 1 ), must_exist = True, asrt = True, msg="looking for definition_list inside method section" )[ 0 ]
		url = self.xpath( definition_list, "./definition_list_item[ starts-with( term, 'URL' ) or starts-with( term, 'API Address' ) ]/definition//paragraph/reference/text()", count=( lambda x: x == 1 ), must_exist = True, asrt = True, msg="looking for url in definition_list" )[ 0 ]
		verbose_write( 0, "url = {}".format( url ) )

		http_method = self.xpath( definition_list, "./definition_list_item[ starts-with( term, 'Method' ) or starts-with( term, 'HTTP Request Type' ) or starts-with( term, 'HTTP Resquest Type' ) ]/definition//paragraph/text()", count=( lambda x: x == 1 ), must_exist = True, asrt = True, msg="looking for http method in definition_list" )[ 0 ]
		verbose_write( 0, "http_method = {}".format( http_method ) )

		request_parameters = self.xpath( definition_list, "./definition_list_item[ starts-with( term, 'Request Parameters' ) ]/definition/bullet_list/list_item/*", count=( lambda x: x >= 1 ), must_exist = True, asrt = True, msg="looking for request parameters in definition_list" )
		verbose_write( 0, "request_parameters = {}".format( [ lxml.etree.tostring( request_parameter ).decode( "utf-8" ) for request_parameter in request_parameters ] ) )

		response_codes = self.xpath( definition_list, "./definition_list_item[ starts-with( term, 'Response Code' ) ]/definition/bullet_list/list_item/*", count=( lambda x: x >= 1 ), must_exist = True, asrt = True, msg="looking for request parameters in definition_list" )
		verbose_write( 0, "response_codes = {}".format( [ lxml.etree.tostring( response_code ).decode( "utf-8" ) for response_code in response_codes ] ) )

		response_example = json.loads( self.xpath( method_section, "./paragraph[ text() = 'Response Example:' ]/following::block_quote[1]//literal_block/text()", count=( lambda x: x == 1 ), must_exist = True, asrt = True, msg="looking for response example in definition_list" )[ 0 ] )
		verbose_write( 0, "response_example = {}".format( json.dumps( response_example ) ) )

		return

	

if __name__ == '__main__':

	default_encoding = locale.getpreferredencoding()

	argument_parser = argparse.ArgumentParser()
	argument_parser.add_argument( "-v", "--verbose", action="count", dest="verbosity", help="increase verbosity level" )
	argument_parser.add_argument( "-i", "--input", action="append", dest="inputs_o", metavar="INPUT", default=[], help="specify input file" )
	argument_parser.add_argument( "input", action="store", nargs="*", help="specify input file" )
	argument_parser.add_argument( "-o", "--output", action="store", dest="output", nargs=1, help="specify output file" )
	argument_parser.add_argument( "-e", "--encoding", action="store", dest="encoding", nargs=1, default=default_encoding, help="specify encoding (default={})".format( default_encoding ) )

	arguments = argument_parser.parse_args( args = sys.argv[1:] )

	if arguments.verbosity is not None:
		def verbose_write( level, string, *, stack_depth=1 ):
			if ( level + 1 ) <= arguments.verbosity:
				## https://gist.github.com/techtonik/2151727
				stack = inspect.stack()
				parentframe = stack[ stack_depth ][ 0 ]
				module = inspect.getmodule( parentframe )
				module_name = ""
				class_name = ""
				if module:
						module_name = module.__name__
				if 'self' in parentframe.f_locals:
						class_name = parentframe.f_locals['self'].__class__.__name__
				code_name = parentframe.f_code.co_name;

				sys.stderr.write( "{}::{}::{}[{}]:{}\n".format( module_name, class_name, code_name, parentframe.f_lineno, string ) )

	else:
		verbose_write = lambda *a: None

	inputs = []
	inputs += arguments.inputs_o
	inputs += arguments.input

	verbose_write( 0, "arguments.verbosity={}".format( json.dumps( arguments.verbosity ) ) )
	verbose_write( 0, "arguments.inputs_o={}".format( json.dumps( arguments.inputs_o ) ) )
	verbose_write( 0, "arguments.input={}".format( json.dumps( arguments.input ) ) )
	verbose_write( 0, "arguments.encoding={}".format( json.dumps( arguments.encoding ) ) )
	verbose_write( 0, "inputs={}".format( json.dumps( inputs ) ) )


	input_fhs = []

	if len( inputs ) > 0:
		for input in inputs:
			input_fhs = input_fhs + [ open( input, "r", encoding=arguments.encoding ) ]
	else:
		input_fhs = input_fhs +[ io.TextIOWrapper( sys.stdin.buffer, encoding=arguments.encoding ) ]

	rst_parser = docutils.parsers.rst.Parser()
	document_settings = DocumentSettings()
	etree_parser = lxml.etree.XMLParser( remove_blank_text=True, resolve_entities=True )

	document_processor = DocumentProcessor()

	for input_fh in input_fhs:
		verbose_write( 0, "input_fh={}".format( input_fh ) )
		input_data = input_fh.read()
		document = docutils.utils.new_document( source_path=input_fh.name, settings=document_settings )
		rst_parser.parse( input_data, document )
		verbose_write( 1, "document.children={}".format( document.children ) )
		verbose_write( 2, "document.asdom()={}".format( document.asdom() ) )
		verbose_write( 5, "document={}".format( document.asdom().toprettyxml( "  ", '\n' ) ) )
		tmp = open( input_fh.name + ".xml", 'w' )
		verbose_write( 2, "tmp.name={}".format( tmp.name ) )
		tmp.write( document.asdom().toprettyxml( "  ", '\n' ) )
		root = lxml.etree.fromstring( document.asdom().toxml(), etree_parser )
		document_processor.process( root )


